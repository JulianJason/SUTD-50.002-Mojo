module adderUnit (
    // ALU inputs
    input alufn[6] ,
    input a[8],
    input b[8],
    // adder outputs
    output added[8],
    output z,                // true is all s = 0
    output v,                // true if overflow
    output n                // true if s[7] is negative=
  ) {
  sig val[9];                 // 9 bit space to allow carry out to bit 9
  /* test cases based on lab documents
      ALUFN position   [3]  [2]  [1]  [0]    operation
                        0    0    0    0     ADD
                        0    0    0    1     SUB
                        0    0    1    0     MUL          
                        0    0    1    1     DIVIDE
                        0    1    0    0     MOD
                        0    1    0    1     1-complement (INV)
  */
  always {
    case(alufn[3:0]) {
      b0000:
        val = a + b;
        
      b0001:
        val = a - b;
      b0010:
        val = a * b;
      b0011:
        val = a / b;
      b0100:
        val = a / b * a;
      b0101:
        val = ~a;
      default:
        val = b000000000;
    }
    added = val[7:0];
    z = |val;
    v = a[7] * b[7] * ~val[7] + ~a[7] * ~b[7] * val[7];
    n = a[7] - b[7];
  }
}
