module avr_detector (
    input clk,               // clock
    input rst,               // reset
    input io_dip [3][8],     // DIP switches on IO Shield
    output channel[4],       // channel we want to sample
    input sample[10],        // sample value
    input sample_channel[4], // channel the sample is from
    input new_sample,        // 1 = new sample
    output outS,
    output outC
  ) {
   
  // This is used to convert 0 to 5 to its corresponding channel
  // output A,B,Cin is taken from channel A9,A7,A5 while the Sum and Cout are piped to A1 and A0
  const CHANNEL_LIST = {4d9,4d8,4d7,4d6,4d5,4d4,4d1,4d0};

   
  .clk(clk), .rst(rst) {
    dff ch[4];                                        // channel counter
  }
   sig a;
   sig b;
   sig cin;
  
  always {
  // a b and cin are assigned to corresponding switches
    a = io_dip[2][0];
    b = io_dip[1][0];
    cin = io_dip[0][0];
    
    
    channel = CHANNEL_LIST[ch.q];                   // set the channel to sample
    
     
    if (new_sample) {                                 // when there is a new sample
      ch.d = ch.q + 1;                                // increment the channel we are sampling
      if (ch.q == 5) {                                 // there are only 8 channels (0 to 7)
        ch.d = 0;      // restart at 0   
      }                 
    }
    outS = CHANNEL_LIST[0];
    outC = CHANNEL_LIST[0];
  }
}